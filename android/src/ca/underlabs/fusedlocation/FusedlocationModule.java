/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package ca.underlabs.fusedlocation;

import java.util.HashMap;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollFunction;
import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.kroll.common.Log;
import org.appcelerator.titanium.TiApplication;

import android.app.Activity;
import android.content.Context;
import android.location.Location;
import android.os.Bundle;

import com.google.android.gms.common.ConnectionResult;
import com.google.android.gms.common.api.GoogleApiClient;
import com.google.android.gms.location.LocationListener;
import com.google.android.gms.location.LocationRequest;
import com.google.android.gms.location.LocationServices;

@Kroll.module(name="FusedlocationModule", id="ca.underlabs.fusedlocation")
public class FusedlocationModule extends KrollModule implements LocationListener, GoogleApiClient.ConnectionCallbacks, GoogleApiClient.OnConnectionFailedListener {
	
	private KrollFunction geoLocationSuccessCallback;
    private KrollFunction geoLocationErrorCallback;
    private Double lastLatitude = new Double("0");;
    private Double lastLongitude = new Double("0");;
    private float lastAccuracy = 0;
    private final int PRIORITY = 100; // 100 = most accurate locations available (GPS) | 104 = "city" level accuracy (10km Wifi & Cell) | 105 = best accuracy possible with zero additional power consumption
    private final long POLLING_FREQ = 5000; // Every second (at most)
    private final long FASTEST_UPDATE_FREQ = 1000; // 1 seconds at fastest
    private float DISTANCE_FILTER = 5; // in meters
    
    Context ctx = TiApplication.getAppCurrentActivity().getApplicationContext();
    
    private LocationRequest locationRequest;
    private GoogleApiClient googleApiClient;
    
    private static final String LCAT = "FusedLocation";

    @Kroll.onAppCreate
    public static void onAppCreate(TiApplication app) {
        Log.d(LCAT, "onAppCreate");
    }

    public void onStart(Activity activity) {
        Log.d(LCAT, "onStart");
        super.onStart(activity);
    }

    public void onStop(Activity activity) {
        Log.d(LCAT, "onStop");
        super.onStop(activity);
    }

    public void onConnected(Bundle bundle) {
        Log.d(LCAT, "onConnected");
        LocationServices.FusedLocationApi.requestLocationUpdates(googleApiClient, locationRequest, (LocationListener)this);
    }

    public void onConnectionSuspended(int i) {
        Log.d(LCAT, "onConnectionSuspended");
    }

    public void onLocationChanged(Location location) {
        if (location != null) {
            Boolean execCallback = false;
            Double latitude = location.getLatitude();
            Double longitude = location.getLongitude();
            float accuracy = location.getAccuracy();
            String provider = String.valueOf(location.getProvider());
            float bearing = location.getBearing();
            float speed = location.getSpeed();
            long timestamp = location.getTime();
            
            if (!this.lastLatitude.equals(latitude)) {
                this.lastLatitude = latitude;
                execCallback = true;
            }
            if (!this.lastLongitude.equals(longitude)) {
                this.lastLongitude = longitude;
                execCallback = true;
            }
            if (this.lastAccuracy != accuracy) {
                this.lastAccuracy = accuracy;
                execCallback = true;
            }
            
            if (execCallback.booleanValue()) {
                
                KrollDict locationObj = new KrollDict();
                locationObj.put("latitude", latitude);
                locationObj.put("longitude", longitude);
                locationObj.put("accuracy", accuracy);
                locationObj.put("heading", bearing);
                locationObj.put("speed", speed);
                locationObj.put("timestamp", timestamp);
                
                // mimic obj structure of iOS location event
                KrollDict coords = new KrollDict();
                coords.put("coords", locationObj);
                coords.put("provider", provider);
                coords.put("success", true);
                coords.put("type", "location");
                
                if (geoLocationSuccessCallback != null)  {
                		this.geoLocationSuccessCallback.call(getKrollObject(), coords);
                }
                
            }
        }
    }

    public void onConnectionFailed(ConnectionResult connectionResult) {
        Log.d(LCAT, "onConnectionFailed");
        HashMap<String, String> event = new HashMap<String, String>();
        event.put("message", "onConnectionFailed");
        event.put("connectionResult", String.valueOf((Object)connectionResult));
        this.geoLocationErrorCallback.call(this.getKrollObject(), event);
    }

    private void buildClient() {
    		ctx = TiApplication.getAppRootOrCurrentActivity().getApplicationContext();
        Log.d(LCAT, "buildClient");
        locationRequest = LocationRequest.create();
        // More Info: https://developers.google.com/android/reference/com/google/android/gms/location/LocationRequest
        locationRequest.setPriority(PRIORITY);
        locationRequest.setInterval(POLLING_FREQ);
        locationRequest.setFastestInterval(FASTEST_UPDATE_FREQ);
        locationRequest.setSmallestDisplacement(DISTANCE_FILTER);
        Activity activity = TiApplication.getAppCurrentActivity();
        GoogleApiClient.Builder builder = new GoogleApiClient.Builder((Context)activity).addApi(LocationServices.API).addConnectionCallbacks((GoogleApiClient.ConnectionCallbacks)this).addOnConnectionFailedListener((GoogleApiClient.OnConnectionFailedListener)this);
        googleApiClient = builder.build();
    }

    @Kroll.method
    public void startGeoLocation(KrollDict props) {
        Log.d(LCAT, "startGeoLocation");
        
        if (props.containsKey((Object)"success")) {
            this.geoLocationSuccessCallback = (KrollFunction)props.get((Object)"success");
        }
        if (props.containsKey((Object)"error")) {
            this.geoLocationErrorCallback = (KrollFunction)props.get((Object)"error");
        }
        if (googleApiClient == null) {
            this.buildClient(); // create location Request
        } else {
            Log.d(LCAT, "GoogleApiClient available");
        }
        if (!googleApiClient.isConnected()) {
            Log.d(LCAT, "GoogleApiClient.connect");
            googleApiClient.connect();
        } else {
            Log.d(LCAT, "GoogleApiClient.isConnected");
        }
    }

    @Kroll.method
    public void stopGeoLocation() {
        Log.d(LCAT, "stopGeoLocation");
        if (googleApiClient != null && googleApiClient.isConnected()) {
            LocationServices.FusedLocationApi.removeLocationUpdates(googleApiClient, (LocationListener)this);
            googleApiClient.disconnect();
        }
    }
    
}